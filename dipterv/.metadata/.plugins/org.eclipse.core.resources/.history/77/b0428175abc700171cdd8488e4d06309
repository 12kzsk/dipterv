package tech.artisanhub.ShapeletTrainerMD;

import libsvm.*;
import java.io.*;
import java.util.*;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Properties;
import libsvm.*;

import tech.artisanhub.ShapeletTrainer1D.ShapeletInputTester;

public class LogBasedShapeletTrainerMDTelcoSVM {

	svm_parameter param;		// set by parse_command_line
	svm_problem prob;		// set by read_problem
	svm_model model;
	String input_file_name;		// set by parse_command_line
	String model_file_name;		// set by parse_command_line
	String error_msg;
	int cross_validation;
	int nr_fold;
	
	// Main fv.: a log alapján megtalálja a shapeleteket
	// Innen hívódik ennek a folyamatnak minden része
	public static void main(String[] args) throws Exception {
		//TODO: nincs semmi TODO csak jelöltem, hogy mit kell kikommentezni a fájl létrehozásához
//		LogProcessorMDSVM.main(args);
		
		LogBasedShapeletTrainerMDTelcoSVM obj = new LogBasedShapeletTrainerMDTelcoSVM();
		obj.run();
	}

			public void run() throws IOException
			{
				read_problem();
			
				model = svm.svm_train(prob,param);
				svm.svm_save_model(model_file_name,model);
			}

			private static double atof(String s)
			{
				double d = Double.valueOf(s).doubleValue();
				if (Double.isNaN(d) || Double.isInfinite(d))
				{
					System.err.print("NaN or Infinity in input\n");
					System.exit(1);
				}
				return(d);
			}

			private static int atoi(String s)
			{
				return Integer.parseInt(s);
			}

			// read in a problem (in svmlight format)
			private void read_problem() throws IOException
			{
				BufferedReader fp = new BufferedReader(new FileReader(input_file_name));
				Vector<Double> vy = new Vector<Double>();
				Vector<svm_node[]> vx = new Vector<svm_node[]>();
				int max_index = 0;

				while(true)
				{
					String line = fp.readLine();
					if(line == null) break;

					StringTokenizer st = new StringTokenizer(line," \t\n\r\f:");

					vy.addElement(atof(st.nextToken()));
					int m = st.countTokens()/2;
					svm_node[] x = new svm_node[m];
					for(int j=0;j<m;j++)
					{
						x[j] = new svm_node();
						x[j].index = atoi(st.nextToken());
						x[j].value = atof(st.nextToken());
					}
					if(m>0) max_index = Math.max(max_index, x[m-1].index);
					vx.addElement(x);
				}

				prob = new svm_problem();
				prob.l = vy.size();
				prob.x = new svm_node[prob.l][];
				for(int i=0;i<prob.l;i++)
					prob.x[i] = vx.elementAt(i);
				prob.y = new double[prob.l];
				for(int i=0;i<prob.l;i++)
					prob.y[i] = vy.elementAt(i);

				if(param.gamma == 0 && max_index > 0)
					param.gamma = 1.0/max_index;

				if(param.kernel_type == svm_parameter.PRECOMPUTED)
					for(int i=0;i<prob.l;i++)
					{
						if (prob.x[i][0].index != 0)
						{
							System.err.print("Wrong kernel matrix: first column must be 0:sample_serial_number\n");
							System.exit(1);
						}
						if ((int)prob.x[i][0].value <= 0 || (int)prob.x[i][0].value > max_index)
						{
							System.err.print("Wrong input format: sample_serial_number out of range\n");
							System.exit(1);
						}
					}

				fp.close();
			}

}