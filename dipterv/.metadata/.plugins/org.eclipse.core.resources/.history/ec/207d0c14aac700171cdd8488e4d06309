package tech.artisanhub.ShapeletTrainerMD;

import libsvm.*;
import java.io.*;
import java.util.*;
import java.io.FileInputStream;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Properties;
import libsvm.*;

import tech.artisanhub.ShapeletTrainer1D.ShapeletInputTester;

public class LogBasedShapeletTrainerMDTelcoSVM {

	// Main fv.: a log alapján megtalálja a shapeleteket
	// Innen hívódik ennek a folyamatnak minden része
	public static void main(String[] args) throws Exception {
		//config file-ban a paraméterek nevei:
		//a fájl nevek végzõdéssel együtt vannak megadva
		/*
		 	logFileName
			trainingDataFileNameCsv
			trainingDataFileNameArff
			shapeletsFileName
			minShapeletLength
			maxShapeletLength
			dimension
			targetVariable
			criticalThreshold
			inputVariables (splitted: ,)
		 */
		
		//propertyk lekérdezése:
		/*	
			Properties prop = new Properties();
			InputStream input = null;
			input = new FileInputStream("config.properties");
			prop.load(input);
		*/
		//TODO: nincs semmi TODO csak jelöltem, hogy mit kell kikommentezni a fájl létrehozásához
//		LogProcessorMDSVM.main(args);

		public fuggveny(){
			svm_parameter param;		// set by parse_command_line
			svm_problem prob;		// set by read_problem
			svm_model model;
			String input_file_name;		// set by parse_command_line
			String model_file_name;		// set by parse_command_line
			String error_msg;
			int cross_validation;
			int nr_fold;

			svm_print_interface svm_print_null = new svm_print_interface()
			{
				public void print(String s) {}
			};			
			
			public void run(String argv[]) throws IOException
			{
				read_problem();
			
				model = svm.svm_train(prob,param);
				svm.svm_save_model(model_file_name,model);
			}

			public static void main(String argv[]) throws IOException
			{
				svm_train t = new svm_train();
				t.run(argv);
			}

			private static double atof(String s)
			{
				double d = Double.valueOf(s).doubleValue();
				if (Double.isNaN(d) || Double.isInfinite(d))
				{
					System.err.print("NaN or Infinity in input\n");
					System.exit(1);
				}
				return(d);
			}

			private static int atoi(String s)
			{
				return Integer.parseInt(s);
			}

			private void parse_command_line(String argv[])
			{
				int i;
				svm_print_interface print_func = null;	// default printing to stdout

				param = new svm_parameter();
				// default values
				param.svm_type = svm_parameter.C_SVC;
				param.kernel_type = svm_parameter.RBF;
				param.degree = 3;
				param.gamma = 0;	// 1/num_features
				param.coef0 = 0;
				param.nu = 0.5;
				param.cache_size = 100;
				param.C = 1;
				param.eps = 1e-3;
				param.p = 0.1;
				param.shrinking = 1;
				param.probability = 0;
				param.nr_weight = 0;
				param.weight_label = new int[0];
				param.weight = new double[0];
				cross_validation = 0;

				// parse options
				for(i=0;i<argv.length;i++)
				{
					if(argv[i].charAt(0) != '-') break;
					if(++i>=argv.length)
						exit_with_help();
					switch(argv[i-1].charAt(1))
					{
						case 's':
							param.svm_type = atoi(argv[i]);
							break;
						case 't':
							param.kernel_type = atoi(argv[i]);
							break;
						case 'd':
							param.degree = atoi(argv[i]);
							break;
						case 'g':
							param.gamma = atof(argv[i]);
							break;
						case 'r':
							param.coef0 = atof(argv[i]);
							break;
						case 'n':
							param.nu = atof(argv[i]);
							break;
						case 'm':
							param.cache_size = atof(argv[i]);
							break;
						case 'c':
							param.C = atof(argv[i]);
							break;
						case 'e':
							param.eps = atof(argv[i]);
							break;
						case 'p':
							param.p = atof(argv[i]);
							break;
						case 'h':
							param.shrinking = atoi(argv[i]);
							break;
						case 'b':
							param.probability = atoi(argv[i]);
							break;
						case 'q':
							print_func = svm_print_null;
							i--;
							break;
						case 'v':
							cross_validation = 1;
							nr_fold = atoi(argv[i]);
							if(nr_fold < 2)
							{
								System.err.print("n-fold cross validation: n must >= 2\n");
								exit_with_help();
							}
							break;
						case 'w':
							++param.nr_weight;
							{
								int[] old = param.weight_label;
								param.weight_label = new int[param.nr_weight];
								System.arraycopy(old,0,param.weight_label,0,param.nr_weight-1);
							}

							{
								double[] old = param.weight;
								param.weight = new double[param.nr_weight];
								System.arraycopy(old,0,param.weight,0,param.nr_weight-1);
							}

							param.weight_label[param.nr_weight-1] = atoi(argv[i-1].substring(2));
							param.weight[param.nr_weight-1] = atof(argv[i]);
							break;
						default:
							System.err.print("Unknown option: " + argv[i-1] + "\n");
							exit_with_help();
					}
				}

				svm.svm_set_print_string_function(print_func);

				// determine filenames

				if(i>=argv.length)
					exit_with_help();

				input_file_name = argv[i];

				if(i<argv.length-1)
					model_file_name = argv[i+1];
				else
				{
					int p = argv[i].lastIndexOf('/');
					++p;	// whew...
					model_file_name = argv[i].substring(p)+".model";
				}
			}

			// read in a problem (in svmlight format)

			private void read_problem() throws IOException
			{
				BufferedReader fp = new BufferedReader(new FileReader(input_file_name));
				Vector<Double> vy = new Vector<Double>();
				Vector<svm_node[]> vx = new Vector<svm_node[]>();
				int max_index = 0;

				while(true)
				{
					String line = fp.readLine();
					if(line == null) break;

					StringTokenizer st = new StringTokenizer(line," \t\n\r\f:");

					vy.addElement(atof(st.nextToken()));
					int m = st.countTokens()/2;
					svm_node[] x = new svm_node[m];
					for(int j=0;j<m;j++)
					{
						x[j] = new svm_node();
						x[j].index = atoi(st.nextToken());
						x[j].value = atof(st.nextToken());
					}
					if(m>0) max_index = Math.max(max_index, x[m-1].index);
					vx.addElement(x);
				}

				prob = new svm_problem();
				prob.l = vy.size();
				prob.x = new svm_node[prob.l][];
				for(int i=0;i<prob.l;i++)
					prob.x[i] = vx.elementAt(i);
				prob.y = new double[prob.l];
				for(int i=0;i<prob.l;i++)
					prob.y[i] = vy.elementAt(i);

				if(param.gamma == 0 && max_index > 0)
					param.gamma = 1.0/max_index;

				if(param.kernel_type == svm_parameter.PRECOMPUTED)
					for(int i=0;i<prob.l;i++)
					{
						if (prob.x[i][0].index != 0)
						{
							System.err.print("Wrong kernel matrix: first column must be 0:sample_serial_number\n");
							System.exit(1);
						}
						if ((int)prob.x[i][0].value <= 0 || (int)prob.x[i][0].value > max_index)
						{
							System.err.print("Wrong input format: sample_serial_number out of range\n");
							System.exit(1);
						}
					}

				fp.close();
			}

		}
	}
}
